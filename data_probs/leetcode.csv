id,title,description,difficulty
1,Two Sum,"Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.


Example 1:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Output: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:
Input: nums = [3,2,4], target = 6
Output: [1,2]

Example 3:
Input: nums = [3,3], target = 6
Output: [0,1]

Constraints:
`2 <= nums.length <= 103`
`-109 <= nums[i] <= 109`
`-109 <= target <= 109`
Only one valid answer exists.",Easy
2,Single Number,"Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.

Follow up: Could you implement a solution with a linear runtime complexity and without using extra memory?

Example 1:
Input: nums = [2,2,1]
Output: 1

Example 2:
Input: nums = [4,1,2,1,2]
Output: 4

Example 3:
Input: nums = [1]
Output: 1

Constraints:
`1 <= nums.length <= 3 * 104`
`-3 * 104 <= nums[i] <= 3 * 104`
Each element in the array appears twice except for one element which appears only once.",Easy
3,Plus One,"Given a non-empty array of decimal digits representing a non-negative integer, increment one to the integer.

The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.

You may assume the integer does not contain any leading zero, except the number 0 itself.


Example 1:
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.


Example 2:
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.


Example 3:
Input: digits = [0]
Output: [1]

Constraints:
`1 <= digits.length <= 100`
`0 <= digits[i] <= 9`",Easy
4,Rotate Array,"Given an array, rotate the array to the right by `k` steps, where `k` is non-negative.


Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

Example 2:
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

Constraints:
`1 <= nums.length <= 2 * 104`
`-231 <= nums[i] <= 231 - 1`
`0 <= k <= 105`
Follow up:
Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.

Could you do it in-place with `O(1)` extra space?",Medium
5,Contains Duplicate,"Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.


Example 1:
Input: nums = [1,2,3,1]
Output: true

Example 2:
Input: nums = [1,2,3,4]
Output: false

Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true

Constraints:
`1 <= nums.length <= 105`
`-109 <= nums[i] <= 109`",Easy
6,Contains Duplicate,"Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.


Example 1:
Input: nums = [1,2,3,1]
Output: true

Example 2:
Input: nums = [1,2,3,4]
Output: false

Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true

Constraints:
`1 <= nums.length <= 105`
`-109 <= nums[i] <= 109`",Easy
7,Contains Duplicate,"Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.


Example 1:
Input: nums = [1,2,3,1]
Output: true

Example 2:
Input: nums = [1,2,3,4]
Output: false

Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true

Constraints:
`1 <= nums.length <= 105`
`-109 <= nums[i] <= 109`",Easy
8,Move Zeroes,"Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.


Example 1:
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]

Example 2:
Input: nums = [0]
Output: [0]

Constraints:
`1 <= nums.length <= 104`
`-231 <= nums[i] <= 231 - 1`
Follow up: Could you minimize the total number of operations done?",Easy
9,Reverse String,"Write a function that reverses a string. The input string is given as an array of characters `s`.


Example 1:
Input: s = [""h"",""e"",""l"",""l"",""o""]
Output: [""o"",""l"",""l"",""e"",""h""]

Example 2:
Input: s = [""H"",""a"",""n"",""n"",""a"",""h""]
Output: [""h"",""a"",""n"",""n"",""a"",""H""]

Constraints:
`1 <= s.length <= 105`
`s[i]` is a printable ascii character.

Follow up: Do not allocate extra space for another array. You must do this by modifying the input array in-place with `O(1)` extra memory.",Easy
10,Valid Anagram,"Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.


Example 1:
Input: s = ""anagram"", t = ""nagaram""
Output: true

Example 2:
Input: s = ""rat"", t = ""car""
Output: false

Constraints:
`1 <= s.length, t.length <= 5 * 104`
`s` and `t` consist of lowercase English letters.

Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?",Easy
11,Longest Common Prefix,"Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `""""`.


Example 1:
Input: strs = [""flower"",""flow"",""flight""]
Output: ""fl""

Example 2:
Input: strs = [""dog"",""racecar"",""car""]
Output: """"
Explanation: There is no common prefix among the input strings.


Constraints:
`0 <= strs.length <= 200`
`0 <= strs[i].length <= 200`
`strs[i]` consists of only lower-case English letters.",Easy
12,Reverse Integer,"Given a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).


Example 1:
Input: x = 123
Output: 321

Example 2:
Input: x = -123
Output: -321

Example 3:
Input: x = 120
Output: 21

Example 4:
Input: x = 0
Output: 0

Constraints:
`-231 <= x <= 231 - 1`",Easy
13,Valid Palindrome,"Given a string `s`, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.


Example 1:
Input: s = ""A man, a plan, a canal: Panama""
Output: true
Explanation: ""amanaplanacanalpanama"" is a palindrome.


Example 2:
Input: s = ""race a car""
Output: false
Explanation: ""raceacar"" is not a palindrome.


Constraints:
`1 <= s.length <= 2 * 105`
`s` consists only of printable ASCII characters.",Easy
14,First Unique Character in a String,"Given a string `s`, return the first non-repeating character in it and return its index. If it does not exist, return `-1`.


Example 1:
Input: s = ""leetcode""
Output: 0

Example 2:
Input: s = ""loveleetcode""
Output: 2

Example 3:
Input: s = ""aabb""
Output: -1

Constraints:
`1 <= s.length <= 105`
`s` consists of only lowercase English letters.",Easy
15,Rotate Image,"You are given an n x n 2D `matrix` representing an image, rotate the image by 90 degrees (clockwise).

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.


Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]

Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]

Example 3:
Input: matrix = [[1]]
Output: [[1]]

Example 4:
Input: matrix = [[1,2],[3,4]]
Output: [[3,1],[4,2]]

Constraints:
`matrix.length == n`
`matrix[i].length == n`
`1 <= n <= 20`
`-1000 <= matrix[i][j] <= 1000`",Medium
16,Best Time to Buy and Sell Stock,"You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.


Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.

Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.


Example 2:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.


Constraints:
`1 <= prices.length <= 105`
`0 <= prices[i] <= 104`",Easy
17,Merge Sorted Array,"Given two sorted integer arrays `nums1` and `nums2`, merge `nums2` into `nums1` as one sorted array.

The number of elements initialized in `nums1` and `nums2` are `m` and `n` respectively. You may assume that `nums1` has a size equal to `m + n` such that it has enough space to hold additional elements from `nums2`.


Example 1:
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]

Example 2:
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]

Constraints:
`nums1.length == m + n`
`nums2.length == n`
`0 <= m, n <= 200`
`1 <= m + n <= 200`
`-109 <= nums1[i], nums2[i] <= 109`",Easy
18,Missing Number,"Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.

Follow up: Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?

Example 1:
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.


Example 2:
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.


Example 3:
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.


Example 4:
Input: nums = [0]
Output: 1
Explanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.


Constraints:
`n == nums.length`
`1 <= n <= 104`
`0 <= nums[i] <= n`
All the numbers of `nums` are unique.",Easy
19,Valid Parentheses,"Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:
Open brackets must be closed by the same type of brackets.

Open brackets must be closed in the correct order.


Example 1:
Input: s = ""()""
Output: true

Example 2:
Input: s = ""()[]{}""
Output: true

Example 3:
Input: s = ""(]""
Output: false

Example 4:
Input: s = ""([)]""
Output: false

Example 5:
Input: s = ""{[]}""
Output: true

Constraints:
`1 <= s.length <= 104`
`s` consists of parentheses only `'()[]{}'`.",Easy
20,Roman to Integer,"Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:
`I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
`X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
`C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given a roman numeral, convert it to an integer.


Example 1:
Input: s = ""III""
Output: 3

Example 2:
Input: s = ""IV""
Output: 4

Example 3:
Input: s = ""IX""
Output: 9

Example 4:
Input: s = ""LVIII""
Output: 58
Explanation: L = 50, V= 5, III = 3.


Example 5:
Input: s = ""MCMXCIV""
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.


Constraints:
`1 <= s.length <= 15`
`s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.

It is guaranteed that `s` is a valid roman numeral in the range `[1, 3999]`.",Easy
21,Power of Three,"Given an integer `n`, return `true` if it is a power of three. Otherwise, return `false`.

An integer `n` is a power of three, if there exists an integer `x` such that `n == 3x`.


Example 1:
Input: n = 27
Output: true

Example 2:
Input: n = 0
Output: false

Example 3:
Input: n = 9
Output: true

Example 4:
Input: n = 45
Output: false

Constraints:
`-231 <= n <= 231 - 1`
Follow up: Could you solve it without loops/recursion?",Easy
22,Count Primes,"Count the number of prime numbers less than a non-negative number, `n`.


Example 1:
Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.


Example 2:
Input: n = 0
Output: 0

Example 3:
Input: n = 1
Output: 0

Constraints:
`0 <= n <= 5 * 106`",Easy
23,Fizz Buzz,"Write a program that outputs the string representation of numbers from 1 to n.

But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.


Example:
n = 15,
Return:
[
    ""1"",
    ""2"",
    ""Fizz"",
    ""4"",
    ""Buzz"",
    ""Fizz"",
    ""7"",
    ""8"",
    ""Fizz"",
    ""Buzz"",
    ""11"",
    ""Fizz"",
    ""13"",
    ""14"",
    ""FizzBuzz""
]",Easy
24,Delete Node in a Linked List,"Write a function to delete a node in a singly-linked list. You will not be given access to the `head` of the list, instead you will be given access to the node to be deleted directly.

It is guaranteed that the node to be deleted is not a tail node in the list.


Example 1:
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.


Example 2:
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.


Example 3:
Input: head = [1,2,3,4], node = 3
Output: [1,2,4]

Example 4:
Input: head = [0,1], node = 0
Output: [1]

Example 5:
Input: head = [-3,5,-99], node = -3
Output: [5,-99]

Constraints:
The number of the nodes in the given list is in the range `[2, 1000]`.

`-1000 <= Node.val <= 1000`
The value of each node in the list is unique.

The `node` to be deleted is in the list and is not a tail node",Easy
25,Remove Nth Node From End of List,"Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

Follow up: Could you do this in one pass?

Example 1:
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:
Input: head = [1], n = 1
Output: []

Example 3:
Input: head = [1,2], n = 1
Output: [1]

Constraints:
The number of nodes in the list is `sz`.

`1 <= sz <= 30`
`0 <= Node.val <= 100`
`1 <= n <= sz`",Medium
26,Reverse Linked List,"Given the `head` of a singly linked list, reverse the list, and return the reversed list.


Example 1:
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Example 2:
Input: head = [1,2]
Output: [2,1]

Example 3:
Input: head = []
Output: []

Constraints:
The number of nodes in the list is the range `[0, 5000]`.

`-5000 <= Node.val <= 5000`
Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?",Easy
27,Merge Two Sorted Lists,"Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.


Example 1:
Input: l1 = [1,2,4], l2 = [1,3,4]
Output: [1,1,2,3,4,4]

Example 2:
Input: l1 = [], l2 = []
Output: []

Example 3:
Input: l1 = [], l2 = [0]
Output: [0]

Constraints:
The number of nodes in both lists is in the range `[0, 50]`.

`-100 <= Node.val <= 100`
Both `l1` and `l2` are sorted in non-decreasing order.",Easy
28,Linked List Cycle,"Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. Note that `pos` is not passed as a parameter.

Return `true` if there is a cycle in the linked list. Otherwise, return `false`.


Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).


Example 2:
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.


Example 3:
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.


Constraints:
The number of the nodes in the list is in the range `[0, 104]`.

`-105 <= Node.val <= 105`
`pos` is `-1` or a valid index in the linked-list.

Follow up: Can you solve it using `O(1)` (i.e. constant) memory?",Easy
29,Palindrome Linked List,"Given the `head` of a singly linked list, return `true` if it is a palindrome.


Example 1:
Input: head = [1,2,2,1]
Output: true

Example 2:
Input: head = [1,2]
Output: false

Constraints:
The number of nodes in the list is in the range `[1, 105]`.

`0 <= Node.val <= 9`
Follow up: Could you do it in `O(n)` time and `O(1)` space?",Easy
30,Group Anagrams,"Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.


Example 1:
Input: strs = [""eat"",""tea"",""tan"",""ate"",""nat"",""bat""]
Output: [[""bat""],[""nat"",""tan""],[""ate"",""eat"",""tea""]]

Example 2:
Input: strs = [""""]
Output: [[""""]]

Example 3:
Input: strs = [""a""]
Output: [[""a""]]

Constraints:
`1 <= strs.length <= 104`
`0 <= strs[i].length <= 100`
`strs[i]` consists of lower-case English letters.",Medium
31,Word Pattern,"Given a `pattern` and a string `s`, find if `s` follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in `pattern` and a non-empty word in `s`.


Example 1:
Input: pattern = ""abba"", s = ""dog cat cat dog""
Output: true

Example 2:
Input: pattern = ""abba"", s = ""dog cat cat fish""
Output: false

Example 3:
Input: pattern = ""aaaa"", s = ""dog cat cat dog""
Output: false

Example 4:
Input: pattern = ""abba"", s = ""dog dog dog dog""
Output: false

Constraints:
`1 <= pattern.length <= 300`
`pattern` contains only lower-case English letters.

`1 <= s.length <= 3000`
`s` contains only lower-case English letters and spaces `' '`.

`s` does not contain any leading or trailing spaces.

All the words in `s` are separated by a single space.",Easy
32,Ransom Note,"Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.

Each letter in the magazine string can only be used once in your ransom note.


Example 1:
Input: ransomNote = ""a"", magazine = ""b""
Output: false

Example 2:
Input: ransomNote = ""aa"", magazine = ""ab""
Output: false

Example 3:
Input: ransomNote = ""aa"", magazine = ""aab""
Output: true

Constraints:
You may assume that both strings contain only lowercase letters.",Easy
33,Count Complete Tree Nodes,"Given the `root` of a complete binary tree, return the number of the nodes in the tree.

According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.


Example 1:
Input: root = [1,2,3,4,5,6]
Output: 6

Example 2:
Input: root = []
Output: 0

Example 3:
Input: root = [1]
Output: 1

Constraints:
The number of nodes in the tree is in the range `[0, 5 * 104]`.

`0 <= Node.val <= 5 * 104`
The tree is guaranteed to be complete.

Follow up: Traversing the tree to count the number of nodes in the tree is an easy solution but with `O(n)` complexity. Could you find a faster algorithm?",Medium
34,Search Insert Position,"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.


Example 1:
Input: nums = [1,3,5,6], target = 5
Output: 2

Example 2:
Input: nums = [1,3,5,6], target = 2
Output: 1

Example 3:
Input: nums = [1,3,5,6], target = 7
Output: 4

Example 4:
Input: nums = [1,3,5,6], target = 0
Output: 0

Example 5:
Input: nums = [1], target = 0
Output: 0

Constraints:
`1 <= nums.length <= 104`
`-104 <= nums[i] <= 104`
`nums` contains distinct values sorted in ascending order.

`-104 <= target <= 104`",Easy
35,Contains Duplicate II,"Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and `abs(i - j) <= k`.


Example 1:
Input: nums = [1,2,3,1], k = 3
Output: true

Example 2:
Input: nums = [1,0,1,1], k = 1
Output: true

Example 3:
Input: nums = [1,2,3,1,2,3], k = 2
Output: false

Constraints:
`1 <= nums.length <= 105`
`-109 <= nums[i] <= 109`
`0 <= k <= 105`",Easy
36,Reverse Words in a String,"Given an input string `s`, reverse the order of the words.

A word is defined as a sequence of non-space characters. The words in `s` will be separated by at least one space.

Return a string of the words in reverse order concatenated by a single space.

Note that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.


Example 1:
Input: s = ""the sky is blue""
Output: ""blue is sky the""

Example 2:
Input: s = ""  hello world  ""
Output: ""world hello""
Explanation: Your reversed string should not contain leading or trailing spaces.


Example 3:
Input: s = ""a good   example""
Output: ""example good a""
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.


Example 4:
Input: s = ""  Bob    Loves  Alice   ""
Output: ""Alice Loves Bob""

Example 5:
Input: s = ""Alice does not even like bob""
Output: ""bob like even not does Alice""

Constraints:
`1 <= s.length <= 104`
`s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.

There is at least one word in `s`.

Follow up: Could you solve it in-place with `O(1)` extra space?",Medium
37,Remove Duplicates from Sorted Array,"Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Clarification:
Confused why the returned value is an integer but your answer is an array?
Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.

Internally you can think of this:
// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);
// any modification to nums in your function would be known by the caller.

// using the length returned by your function, it prints the first len elements.

for (int i = 0; i < len; i++) {
    print(nums[i]);
}

Example 1:
Input: nums = [1,1,2]
Output: 2, nums = [1,2]
Explanation: Your function should return length = `2`, with the first two elements of `nums` being `1` and `2` respectively. It doesn't matter what you leave beyond the returned length.


Example 2:
Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4]
Explanation: Your function should return length = `5`, with the first five elements of `nums` being modified to `0`, `1`, `2`, `3`, and `4` respectively. It doesn't matter what values are set beyond the returned length.


Constraints:
`0 <= nums.length <= 3 * 104`
`-104 <= nums[i] <= 104`
`nums` is sorted in ascending order.",Easy
38,Remove Element,"Given an array nums and a value `val`, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with `O(1)` extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Clarification:
Confused why the returned value is an integer but your answer is an array?
Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.

Internally you can think of this:
// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);
// any modification to nums in your function would be known by the caller.

// using the length returned by your function, it prints the first len elements.

for (int i = 0; i < len; i++) {
    print(nums[i]);
}

Example 1:
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2]
Explanation: Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length. For example if you return 2 with nums = [2,2,3,3] or nums = [2,2,0,0], your answer will be accepted.


Example 2:
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3]
Explanation: Your function should return length = `5`, with the first five elements of `nums` containing `0`, `1`, `3`, `0`, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length.


Constraints:
`0 <= nums.length <= 100`
`0 <= nums[i] <= 50`
`0 <= val <= 100`",Easy
39,Remove All Adjacent Duplicates In String,"Given a string `S` of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.

We repeatedly make duplicate removals on S until we no longer can.

Return the final string after all such duplicate removals have been made.  It is guaranteed the answer is unique.


Example 1:
Input: ""abbaca""
Output: ""ca""
Explanation: 
For example, in ""abbaca"" we could remove ""bb"" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is ""aaca"", of which only ""aa"" is possible, so the final string is ""ca"".

Note:
`1 <= S.length <= 20000`
`S` consists only of English lowercase letters.",Easy
40,Same Tree,"Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.


Example 1:
Input: p = [1,2,3], q = [1,2,3]
Output: true

Example 2:
Input: p = [1,2], q = [1,null,2]
Output: false

Example 3:
Input: p = [1,2,1], q = [1,1,2]
Output: false

Constraints:
The number of nodes in both trees is in the range `[0, 100]`.

`-104 <= Node.val <= 104`",Easy
41,Count Negative Numbers in a Sorted Matrix,"Given a `m x n` matrix `grid` which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in `grid`.


Example 1:
Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
Output: 8
Explanation: There are 8 negatives number in the matrix.


Example 2:
Input: grid = [[3,2],[1,0]]
Output: 0

Example 3:
Input: grid = [[1,-1],[-1,-1]]
Output: 3

Example 4:
Input: grid = [[-1]]
Output: 1

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 100`
`-100 <= grid[i][j] <= 100`
Follow up: Could you find an `O(n + m)` solution?",Easy
42,Best Time to Buy and Sell Stock II,"You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).


Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.

Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.


Example 2:
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.

Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.


Example 3:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e., max profit = 0.


Constraints:
`1 <= prices.length <= 3 * 104`
`0 <= prices[i] <= 104`",Easy
43,Add Digits,"Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.


Example 1:
Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.


Example 2:
Input: num = 0
Output: 0

Constraints:
`0 <= num <= 231 - 1`
Follow up: Could you do it without any loop/recursion in `O(1)` runtime?",Easy
44,Count Integers With Even Digit Sum,"Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even.

The digit sum of a positive integer is the sum of all its digits.

 

Example 1:

Input: num = 4
Output: 2
Explanation:
The only integers less than or equal to 4 whose digit sums are even are 2 and 4.    
Example 2:

Input: num = 30
Output: 14
Explanation:
The 14 integers less than or equal to 30 whose digit sums are even are
2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28.
 

Constraints:

1 <= num <= 1000",Easy
45,Count Primes,"Count the number of prime numbers less than a non-negative number, `n`.


Example 1:
Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.


Example 2:
Input: n = 0
Output: 0

Example 3:
Input: n = 1
Output: 0

Constraints:
`0 <= n <= 5 * 106`",Easy
46,Binary Search,"Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.


Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

Constraints:
`1 <= nums.length <= 104`
`-9999 <= nums[i], target <= 9999`
All the integers in `nums` are unique.

`nums` is sorted in an ascending order.",Easy
47,Subtree of Another Tree,"Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.


Example 1:
Given tree s:
     3
    / \
   4   5
  / \
 1   2
Given tree t:
   4 
  / \
 1   2
Return true, because t has the same structure and node values with a subtree of s.


Example 2:
Given tree s:
     3
    / \
   4   5
  / \
 1   2
    /
   0
Given tree t:
   4
  / \
 1   2
Return false.",Easy
48,Last Stone Weight,"We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights `x` and `y` with `x <= y`.  The result of this smash is:
If `x == y`, both stones are totally destroyed;
If `x != y`, the stone of weight `x` is totally destroyed, and the stone of weight `y` has new weight `y-x`.

At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)

Example 1:
Input: [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.

Note:
`1 <= stones.length <= 30`
`1 <= stones[i] <= 1000`",Easy
49,Climbing Stairs,"You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

Example 1:
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.

1. 1 step + 1 step
2. 2 steps

Example 2:
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.

1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

Constraints:
`1 <= n <= 45`",Easy
50,Happy Number,"Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.

 

Example 1:

Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
Example 2:

Input: n = 2
Output: false
 

Constraints:

1 <= n <= 231 - 1",Easy
51,Add Two Numbers,"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.


Example 1:
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.


Example 2:
Input: l1 = [0], l2 = [0]
Output: [0]

Example 3:
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]

Constraints:
The number of nodes in each linked list is in the range `[1, 100]`.

`0 <= Node.val <= 9`
It is guaranteed that the list represents a number that does not have leading zeros.",Medium
52,Intersection of Two Linked Lists,"Given the heads of two singly linked-lists `headA` and `headB`, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return `null`.

For example, the following two linked lists begin to intersect at node `c1`:
It is guaranteed that there are no cycles anywhere in the entire linked structure.

Note that the linked lists must retain their original structure after the function returns.


Example 1:
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Intersected at '8'
Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).

From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.


Example 2:
Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Intersected at '2'
Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).

From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.


Example 3:
Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: No intersection
Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.

Explanation: The two lists do not intersect, so return null.


Constraints:
The number of nodes of `listA` is in the `m`.

The number of nodes of `listB` is in the `n`.

`0 <= m, n <= 3 * 104`
`1 <= Node.val <= 105`
`0 <= skipA <= m`
`0 <= skipB <= n`
`intersectVal` is `0` if `listA` and `listB` do not intersect.

`intersectVal == listA[skipA + 1] == listB[skipB + 1]` if `listA` and `listB` intersect.

Follow up: Could you write a solution that runs in `O(n)` time and use only `O(1)` memory?",Easy
53,Word Search,"Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.


Example 1:
Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCCED""
Output: true

Example 2:
Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""SEE""
Output: true

Example 3:
Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCB""
Output: false

Constraints:
`m == board.length`
`n = board[i].length`
`1 <= m, n <= 6`
`1 <= word.length <= 15`
`board` and `word` consists of only lowercase and uppercase English letters.

Follow up: Could you use search pruning to make your solution faster with a larger `board`?",Medium
54,Subsets,"Given an integer array `nums` of unique elements, return all possible subsets (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.


Example 1:
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

Example 2:
Input: nums = [0]
Output: [[],[0]]

Constraints:
`1 <= nums.length <= 10`
`-10 <= nums[i] <= 10`
All the numbers of `nums` are unique.",Medium
55,Sort Colors,"Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.


Example 1:
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

Example 2:
Input: nums = [2,0,1]
Output: [0,1,2]

Example 3:
Input: nums = [0]
Output: [0]

Example 4:
Input: nums = [1]
Output: [1]

Constraints:
`n == nums.length`
`1 <= n <= 300`
`nums[i]` is `0`, `1`, or `2`.

Follow up:
Could you solve this problem without using the library's sort function?
Could you come up with a one-pass algorithm using only `O(1)` constant space?",Medium
56,Kth Largest Element in an Array,"Given an integer array `nums` and an integer `k`, return the `kth` largest element in the array.

Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element.


Example 1:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5

Example 2:
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4

Constraints:
`1 <= k <= nums.length <= 104`
`-104 <= nums[i] <= 104`",Medium
57,Find Peak Element,"A peak element is an element that is strictly greater than its neighbors.

Given an integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that `nums[-1] = nums[n] = -∞`.


Example 1:
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.


Example 2:
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.


Constraints:
`1 <= nums.length <= 1000`
`-231 <= nums[i] <= 231 - 1`
`nums[i] != nums[i + 1]` for all valid `i`.

Follow up: Could you implement a solution with logarithmic complexity?",Medium
58,Divide Two Integers,"Given two integers `dividend` and `divisor`, divide two integers without using multiplication, division, and mod operator.

Return the quotient after dividing `dividend` by `divisor`.

The integer division should truncate toward zero, which means losing its fractional part. For example, `truncate(8.345) = 8` and `truncate(-2.7335) = -2`.

Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: `[−231, 231 − 1]`. For this problem, assume that your function returns `231 − 1` when the division result overflows.


Example 1:
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.


Example 2:
Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = truncate(-2.33333..) = -2.


Example 3:
Input: dividend = 0, divisor = 1
Output: 0

Example 4:
Input: dividend = 1, divisor = 1
Output: 1

Constraints:
`-231 <= dividend, divisor <= 231 - 1`
`divisor != 0`",Medium
59,Sum of Two Integers,"Given two integers `a` and `b`, return the sum of the two integers without using the operators `+` and `-`.


Example 1:
Input: a = 1, b = 2
Output: 3

Example 2:
Input: a = 2, b = 3
Output: 5

Constraints:
`-1000 <= a, b <= 1000`",Medium
60,Majority Element,"Given an array `nums` of size `n`, return the majority element.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.


Example 1:
Input: nums = [3,2,3]
Output: 3

Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2

Constraints:
`n == nums.length`
`1 <= n <= 5 * 104`
`-231 <= nums[i] <= 231 - 1`
Follow-up: Could you solve the problem in linear time and in `O(1)` space?",Easy
61,Kth Smallest Element in a BST,"Given the `root` of a binary search tree, and an integer `k`, return the `kth` (1-indexed) smallest element in the tree.


Example 1:
Input: root = [3,1,4,null,2], k = 1
Output: 1

Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3

Constraints:
The number of nodes in the tree is `n`.

`1 <= k <= n <= 104`
`0 <= Node.val <= 104`
Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?",Medium
62,3Sum,"Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.


Example 1:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Example 2:
Input: nums = []
Output: []

Example 3:
Input: nums = [0]
Output: []

Constraints:
`0 <= nums.length <= 3000`
`-105 <= nums[i] <= 105`",Medium
63,Remove Duplicates from Sorted Array II,"Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra memory.

Clarification:
Confused why the returned value is an integer, but your answer is an array?
Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller.

Internally you can think of this:
// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);
// any modification to nums in your function would be known by the caller.

// using the length returned by your function, it prints the first len elements.

for (int i = 0; i < len; i++) {
    print(nums[i]);
}

Example 1:
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3]
Explanation: Your function should return length = `5`, with the first five elements of `nums` being `1, 1, 2, 2` and 3 respectively. It doesn't matter what you leave beyond the returned length.


Example 2:
Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3]
Explanation: Your function should return length = `7`, with the first seven elements of `nums` being modified to `0`, 0, 1, 1, 2, 3 and 3 respectively. It doesn't matter what values are set beyond the returned length.


Constraints:
`1 <= nums.length <= 3 * 104`
`-104 <= nums[i] <= 104`
`nums` is sorted in ascending order.",Medium
64,Rotate Array,"Given an array, rotate the array to the right by `k` steps, where `k` is non-negative.


Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

Example 2:
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

Constraints:
`1 <= nums.length <= 2 * 104`
`-231 <= nums[i] <= 231 - 1`
`0 <= k <= 105`
Follow up:
Try to come up with as many solutions as you can. There are at least three different ways to solve this problem.

Could you do it in-place with `O(1)` extra space?",Medium
65,Best Time to Buy and Sell Stock II,"You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).


Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.

Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.


Example 2:
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.

Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.


Example 3:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e., max profit = 0.


Constraints:
`1 <= prices.length <= 3 * 104`
`0 <= prices[i] <= 104`",Easy
66,Reverse Words in a String,"Given an input string `s`, reverse the order of the words.

A word is defined as a sequence of non-space characters. The words in `s` will be separated by at least one space.

Return a string of the words in reverse order concatenated by a single space.

Note that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.


Example 1:
Input: s = ""the sky is blue""
Output: ""blue is sky the""

Example 2:
Input: s = ""  hello world  ""
Output: ""world hello""
Explanation: Your reversed string should not contain leading or trailing spaces.


Example 3:
Input: s = ""a good   example""
Output: ""example good a""
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.


Example 4:
Input: s = ""  Bob    Loves  Alice   ""
Output: ""Alice Loves Bob""

Example 5:
Input: s = ""Alice does not even like bob""
Output: ""bob like even not does Alice""

Constraints:
`1 <= s.length <= 104`
`s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.

There is at least one word in `s`.

Follow up: Could you solve it in-place with `O(1)` extra space?",Medium
67,Remove Nth Node From End of List,"Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

Follow up: Could you do this in one pass?

Example 1:
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:
Input: head = [1], n = 1
Output: []

Example 3:
Input: head = [1,2], n = 1
Output: [1]

Constraints:
The number of nodes in the list is `sz`.

`1 <= sz <= 30`
`0 <= Node.val <= 100`
`1 <= n <= sz`",Medium
68,Maximum Product Subarray,"Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return the product.

It is guaranteed that the answer will fit in a 32-bit integer.

A subarray is a contiguous subsequence of the array.


Example 1:
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.


Example 2:
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.


Constraints:
`1 <= nums.length <= 2 * 104`
`-10 <= nums[i] <= 10`
The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.",Medium
69,Combination Sum,"Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`. You may return the combinations in any order.

The same number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

It is guaranteed that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.


Example 1:
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.

7 is a candidate, and 7 = 7.

These are the only two combinations.


Example 2:
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]

Example 3:
Input: candidates = [2], target = 1
Output: []

Example 4:
Input: candidates = [1], target = 1
Output: [[1]]

Example 5:
Input: candidates = [1], target = 2
Output: [[1,1]]

Constraints:
`1 <= candidates.length <= 30`
`1 <= candidates[i] <= 200`
All elements of `candidates` are distinct.

`1 <= target <= 500`",Medium
70,Permutations,"Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.


Example 1:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

Example 2:
Input: nums = [0,1]
Output: [[0,1],[1,0]]

Example 3:
Input: nums = [1]
Output: [[1]]

Constraints:
`1 <= nums.length <= 6`
`-10 <= nums[i] <= 10`
All the integers of `nums` are unique.",Medium
71,Word Break,"Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.

Note that the same word in the dictionary may be reused multiple times in the segmentation.


Example 1:
Input: s = ""leetcode"", wordDict = [""leet"",""code""]
Output: true
Explanation: Return true because ""leetcode"" can be segmented as ""leet code"".


Example 2:
Input: s = ""applepenapple"", wordDict = [""apple"",""pen""]
Output: true
Explanation: Return true because ""applepenapple"" can be segmented as ""apple pen apple"".

Note that you are allowed to reuse a dictionary word.


Example 3:
Input: s = ""catsandog"", wordDict = [""cats"",""dog"",""sand"",""and"",""cat""]
Output: false

Constraints:
`1 <= s.length <= 300`
`1 <= wordDict.length <= 1000`
`1 <= wordDict[i].length <= 20`
`s` and `wordDict[i]` consist of only lowercase English letters.

All the strings of `wordDict` are unique.",Medium
72,Find All Anagrams in a String,"Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.

Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.

The order of output does not matter.


Example 1:
Input:
s: ""cbaebabacd"" p: ""abc""
Output:
[0, 6]
Explanation:
The substring with start index = 0 is ""cba"", which is an anagram of ""abc"".

The substring with start index = 6 is ""bac"", which is an anagram of ""abc"".


Example 2:
Input:
s: ""abab"" p: ""ab""
Output:
[0, 1, 2]
Explanation:
The substring with start index = 0 is ""ab"", which is an anagram of ""ab"".

The substring with start index = 1 is ""ba"", which is an anagram of ""ab"".

The substring with start index = 2 is ""ab"", which is an anagram of ""ab"".",Medium
73,Merge Intervals,"Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.


Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].


Example 2:
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.


Constraints:
`1 <= intervals.length <= 104`
`intervals[i].length == 2`
`0 <= starti <= endi <= 104`",Medium
74,Maximum Subarray,"Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.


Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.


Example 2:
Input: nums = [1]
Output: 1

Example 3:
Input: nums = [5,4,-1,7,8]
Output: 23

Constraints:
`1 <= nums.length <= 3 * 104`
`-105 <= nums[i] <= 105`
Follow up: If you have figured out the `O(n)` solution, try coding another solution using the divide and conquer approach, which is more subtle.",Easy
75,Binary Tree Right Side View,"Given the `root` of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.


Example 1:
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]

Example 2:
Input: root = [1,null,3]
Output: [1,3]

Example 3:
Input: root = []
Output: []

Constraints:
The number of nodes in the tree is in the range `[0, 100]`.

`-100 <= Node.val <= 100`",Medium
76,Search in Rotated Sorted Array,"There is an integer array `nums` sorted in ascending order (with distinct values).

Prior to being passed to your function, `nums` is rotated at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (0-indexed). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.


Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Example 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

Example 3:
Input: nums = [1], target = 0
Output: -1

Constraints:
`1 <= nums.length <= 5000`
`-104 <= nums[i] <= 104`
All values of `nums` are unique.

`nums` is guaranteed to be rotated at some pivot.

`-104 <= target <= 104`
Follow up: Can you achieve this in `O(log n)` time complexity?",Medium
77,Replace Words,"In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word successor. For example, when the root `""an""` is followed by the successor word `""other""`, we can form a new word `""another""`.

Given a `dictionary` consisting of many roots and a `sentence` consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. If a successor can be replaced by more than one root, replace it with the root that has the shortest length.

Return the `sentence` after the replacement.


Example 1:
Input: dictionary = [""cat"",""bat"",""rat""], sentence = ""the cattle was rattled by the battery""
Output: ""the cat was rat by the bat""

Example 2:
Input: dictionary = [""a"",""b"",""c""], sentence = ""aadsfasf absbs bbab cadsfafs""
Output: ""a a b c""

Example 3:
Input: dictionary = [""a"", ""aa"", ""aaa"", ""aaaa""], sentence = ""a aa a aaaa aaa aaa aaa aaaaaa bbb baba ababa""
Output: ""a a a a a a a a bbb baba a""

Example 4:
Input: dictionary = [""catt"",""cat"",""bat"",""rat""], sentence = ""the cattle was rattled by the battery""
Output: ""the cat was rat by the bat""

Example 5:
Input: dictionary = [""ac"",""ab""], sentence = ""it is abnormal that this solution is accepted""
Output: ""it is ab that this solution is ac""

Constraints:
`1 <= dictionary.length <= 1000`
`1 <= dictionary[i].length <= 100`
`dictionary[i]` consists of only lower-case letters.

`1 <= sentence.length <= 10^6`
`sentence` consists of only lower-case letters and spaces.

The number of words in `sentence` is in the range `[1, 1000]`
The length of each word in `sentence` is in the range `[1, 1000]`
Each two consecutive words in `sentence` will be separated by exactly one space.

`sentence` does not have leading or trailing spaces.",Medium
78,Validate Binary Search Tree,"Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node's key.

The right subtree of a node contains only nodes with keys greater than the node's key.

Both the left and right subtrees must also be binary search trees.


Example 1:
Input: root = [2,1,3]
Output: true

Example 2:
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.


Constraints:
The number of nodes in the tree is in the range `[1, 104]`.

`-231 <= Node.val <= 231 - 1`",Medium
79,Delete Nodes And Return Forest,"Given the `root` of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in `to_delete`, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest. You may return the result in any order.


Example 1:
Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
Output: [[1,2,null,4],[6],[7]]

Example 2:
Input: root = [1,2,4,null,3], to_delete = [3]
Output: [[1,2,4]]

Constraints:
The number of nodes in the given tree is at most `1000`.

Each node has a distinct value between `1` and `1000`.

`to_delete.length <= 1000`
`to_delete` contains distinct values between `1` and `1000`.",Medium
80,Count Number of Nice Subarrays,"Given an array of integers `nums` and an integer `k`. A continuous subarray is called nice if there are `k` odd numbers on it.

Return the number of nice sub-arrays.


Example 1:
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].


Example 2:
Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There is no odd numbers in the array.


Example 3:
Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16

Constraints:
`1 <= nums.length <= 50000`
`1 <= nums[i] <= 10^5`
`1 <= k <= nums.length`",Medium
81,Apply Discount Every n Orders,"There is a sale in a supermarket, there will be a `discount` every `n` customer.

There are some products in the supermarket where the id of the `i-th` product is `products[i]` and the price per unit of this product is `prices[i]`.

The system will count the number of customers and when the `n-th` customer arrive he/she will have a `discount` on the bill. (i.e if the cost is `x` the new cost is `x - (discount * x) / 100`). Then the system will start counting customers again.

The customer orders a certain amount of each product where `product[i]` is the id of the `i-th` product the customer ordered and `amount[i]` is the number of units the customer ordered of that product.

Implement the `Cashier` class:
`Cashier(int n, int discount, int[] products, int[] prices)` Initializes the object with `n`, the `discount`, the `products` and their `prices`.

`double getBill(int[] product, int[] amount)` returns the value of the bill and apply the discount if needed. Answers within `10^-5` of the actual value will be accepted as correct.


Example 1:
Input
[""Cashier"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill""]
[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]
Output
[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]
Explanation
Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);
cashier.getBill([1,2],[1,2]);                        // return 500.0, bill = 1 * 100 + 2 * 200 = 500.

cashier.getBill([3,7],[10,10]);                      // return 4000.0
cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0, The bill was 1600.0 but as this is the third customer, he has a discount of 50% which means his bill is only 1600 - 1600 * (50 / 100) = 800.

cashier.getBill([4],[10]);                           // return 4000.0
cashier.getBill([7,3],[10,10]);                      // return 4000.0
cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0, Bill was 14700.0 but as the system counted three more customers, he will have a 50% discount and the bill becomes 7350.0
cashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0

Constraints:
`1 <= n <= 10^4`
`0 <= discount <= 100`
`1 <= products.length <= 200`
`1 <= products[i] <= 200`
There are not repeated elements in the array `products`.

`prices.length == products.length`
`1 <= prices[i] <= 1000`
`1 <= product.length <= products.length`
`product[i]` exists in `products`.

`amount.length == product.length`
`1 <= amount[i] <= 1000`
At most `1000` calls will be made to `getBill`.

Answers within `10^-5` of the actual value will be accepted as correct.",Medium
82,Integer to Roman,"Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:
`I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
`X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
`C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given an integer, convert it to a roman numeral.


Example 1:
Input: num = 3
Output: ""III""

Example 2:
Input: num = 4
Output: ""IV""

Example 3:
Input: num = 9
Output: ""IX""

Example 4:
Input: num = 58
Output: ""LVIII""
Explanation: L = 50, V = 5, III = 3.


Example 5:
Input: num = 1994
Output: ""MCMXCIV""
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.


Constraints:
`1 <= num <= 3999`",Medium
83,Valid Sudoku,"Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits `1-9` without repetition.

Each column must contain the digits `1-9` without repetition.

Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.

Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable.

Only the filled cells need to be validated according to the mentioned rules.


Example 1:
Input: board = 
[[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: true

Example 2:
Input: board = 
[[""8"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: false

Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.


Constraints:
`board.length == 9`
`board[i].length == 9`
`board[i][j]` is a digit or `'.'`.",Medium
84,Find Duplicate Subtrees,"Given the `root` of a binary tree, return all duplicate subtrees.

For each kind of duplicate subtrees, you only need to return the root node of any one of them.

Two trees are duplicate if they have the same structure with the same node values.


Example 1:
Input: root = [1,2,3,4,null,2,4,null,null,4]
Output: [[2,4],[4]]

Example 2:
Input: root = [2,1,1]
Output: [[1]]

Example 3:
Input: root = [2,2,2,3,null,3,null]
Output: [[2,3],[3]]

Constraints:
The number of the nodes in the tree will be in the range `[1, 10^4]`
`-200 <= Node.val <= 200`",Medium
85,Longest Word in Dictionary,"Given an array of strings `words` representing an English Dictionary, return the longest word in `words` that can be built one character at a time by other words in `words`.

If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.


Example 1:
Input: words = [""w"",""wo"",""wor"",""worl"",""world""]
Output: ""world""
Explanation: The word ""world"" can be built one character at a time by ""w"", ""wo"", ""wor"", and ""worl"".


Example 2:
Input: words = [""a"",""banana"",""app"",""appl"",""ap"",""apply"",""apple""]
Output: ""apple""
Explanation: Both ""apply"" and ""apple"" can be built from other words in the dictionary. However, ""apple"" is lexicographically smaller than ""apply"".


Constraints:
`1 <= words.length <= 1000`
`1 <= words[i].length <= 30`
`words[i]` consists of lowercase English letters.",Easy
86,Find All Duplicates in an Array,"Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.

Find all the elements that appear twice in this array.

Could you do it without extra space and in O(n) runtime?

Example:
Input:
[4,3,2,7,8,2,3,1]
Output:
[2,3]",Medium
87,Top K Frequent Words,"Given a non-empty list of words, return the k most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.


Example 1:
Input: [""i"", ""love"", ""leetcode"", ""i"", ""love"", ""coding""], k = 2
Output: [""i"", ""love""]
Explanation: ""i"" and ""love"" are the two most frequent words.

    Note that ""i"" comes before ""love"" due to a lower alphabetical order.


Example 2:
Input: [""the"", ""day"", ""is"", ""sunny"", ""the"", ""the"", ""the"", ""sunny"", ""is"", ""is""], k = 4
Output: [""the"", ""is"", ""sunny"", ""day""]
Explanation: ""the"", ""is"", ""sunny"" and ""day"" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.

Note:
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.

Input words contain only lowercase letters.
Follow up:
Try to solve it in O(n log k) time and O(n) extra space.",Medium
88,Largest Number,"Given a list of non-negative integers `nums`, arrange them such that they form the largest number.

Note: The result may be very large, so you need to return a string instead of an integer.


Example 1:
Input: nums = [10,2]
Output: ""210""

Example 2:
Input: nums = [3,30,34,5,9]
Output: ""9534330""

Example 3:
Input: nums = [1]
Output: ""1""

Example 4:
Input: nums = [10]
Output: ""10""

Constraints:
`1 <= nums.length <= 100`
`0 <= nums[i] <= 109`",Medium
89,Custom Sort String,"`S` and `T` are strings composed of lowercase letters. In `S`, no letter occurs more than once.

`S` was sorted in some custom order previously. We want to permute the characters of `T` so that they match the order that `S` was sorted. More specifically, if `x` occurs before `y` in `S`, then `x` should occur before `y` in the returned string.

Return any permutation of `T` (as a string) that satisfies this property.


Example :
Input: 
S = ""cba""
T = ""abcd""
Output: ""cbad""
Explanation: 
""a"", ""b"", ""c"" appear in S, so the order of ""a"", ""b"", ""c"" should be ""c"", ""b"", and ""a"". 
Since ""d"" does not appear in S, it can be at any position in T. ""dcba"", ""cdba"", ""cbda"" are also valid outputs.

Note:
`S` has length at most `26`, and no character is repeated in `S`.

`T` has length at most `200`.

`S` and `T` consist of lowercase letters only.",Medium
90,Top K Frequent Words,"Given a non-empty list of words, return the k most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.


Example 1:
Input: [""i"", ""love"", ""leetcode"", ""i"", ""love"", ""coding""], k = 2
Output: [""i"", ""love""]
Explanation: ""i"" and ""love"" are the two most frequent words.

    Note that ""i"" comes before ""love"" due to a lower alphabetical order.


Example 2:
Input: [""the"", ""day"", ""is"", ""sunny"", ""the"", ""the"", ""the"", ""sunny"", ""is"", ""is""], k = 4
Output: [""the"", ""is"", ""sunny"", ""day""]
Explanation: ""the"", ""is"", ""sunny"" and ""day"" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.

Note:
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.

Input words contain only lowercase letters.
Follow up:
Try to solve it in O(n log k) time and O(n) extra space.",Medium
91,Container With Most Water,"Given `n` non-negative integers `a1, a2, ..., an` , where each represents a point at coordinate `(i, ai)`. `n` vertical lines are drawn such that the two endpoints of the line `i` is at `(i, ai)` and `(i, 0)`. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.

Notice that you may not slant the container.


Example 1:
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.


Example 2:
Input: height = [1,1]
Output: 1

Example 3:
Input: height = [4,3,2,1,4]
Output: 16

Example 4:
Input: height = [1,2,1]
Output: 2

Constraints:
`n == height.length`
`2 <= n <= 105`
`0 <= height[i] <= 104`",Medium
92,Min Stack,"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

Implement the `MinStack` class:
`MinStack()` initializes the stack object.

`void push(val)` pushes the element `val` onto the stack.

`void pop()` removes the element on the top of the stack.

`int top()` gets the top element of the stack.

`int getMin()` retrieves the minimum element in the stack.


Example 1:
Input
[""MinStack"",""push"",""push"",""push"",""getMin"",""pop"",""top"",""getMin""]
[[],[-2],[0],[-3],[],[],[],[]]
Output
[null,null,null,null,-3,null,0,-2]
Explanation
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2

Constraints:
`-231 <= val <= 231 - 1`
Methods `pop`, `top` and `getMin` operations will always be called on non-empty stacks.

At most `3 * 104` calls will be made to `push`, `pop`, `top`, and `getMin`.",Easy
93,Daily Temperatures,"Given a list of daily temperatures `T`, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put `0` instead.

For example, given the list of temperatures `T = [73, 74, 75, 71, 69, 72, 76, 73]`, your output should be `[1, 1, 4, 2, 1, 1, 0, 0]`.

Note:
The length of `temperatures` will be in the range `[1, 30000]`.

Each temperature will be an integer in the range `[30, 100]`.",Medium
94,Reorder List,"You are given the head of a singly linked-list. The list can be represented as:
L0 → L1 → ... → Ln - 1 → Ln
Reorder the list to be on the following form:
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → ...

You may not modify the values in the list's nodes. Only nodes themselves may be changed.


Example 1:
Input: head = [1,2,3,4]
Output: [1,4,2,3]

Example 2:
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]

Constraints:
The number of nodes in the list is in the range `[1, 5 * 104]`.

`1 <= Node.val <= 1000`",Medium
95,Lowest Common Ancestor of a Binary Search Tree,"Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself).”

Example 1:
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.


Example 2:
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.


Example 3:
Input: root = [2,1], p = 2, q = 1
Output: 2

Constraints:
The number of nodes in the tree is in the range `[2, 105]`.

`-109 <= Node.val <= 109`
All `Node.val` are unique.

`p != q`
`p` and `q` will exist in the BST.",Easy
96,Sort the Matrix Diagonally,"A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix's end. For example, the matrix diagonal starting from `mat[2][0]`, where `mat` is a `6 x 3` matrix, includes cells `mat[2][0]`, `mat[3][1]`, and `mat[4][2]`.

Given an `m x n` matrix `mat` of integers, sort each matrix diagonal in ascending order and return the resulting matrix.


Example 1:
Input: mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
Output: [[1,1,1,1],[1,2,2,2],[1,2,3,3]]

Example 2:
Input: mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]
Output: [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]

Constraints:
`m == mat.length`
`n == mat[i].length`
`1 <= m, n <= 100`
`1 <= mat[i][j] <= 100`",Medium
97,Find K Closest Elements,"Given a sorted integer array `arr`, two integers `k` and `x`, return the `k` closest integers to `x` in the array. The result should also be sorted in ascending order.

An integer `a` is closer to `x` than an integer `b` if:
`|a - x| < |b - x|`, or
`|a - x| == |b - x|` and `a < b`

Example 1:
Input: arr = [1,2,3,4,5], k = 4, x = 3
Output: [1,2,3,4]

Example 2:
Input: arr = [1,2,3,4,5], k = 4, x = -1
Output: [1,2,3,4]

Constraints:
`1 <= k <= arr.length`
`1 <= arr.length <= 104`
`arr` is sorted in ascending order.

`-104 <= arr[i], x <= 104`",Medium
98,4Sum,"Given an array `nums` of n integers and an integer `target`, are there elements a, b, c, and d in `nums` such that a + b + c + d = `target`? Find all unique quadruplets in the array which gives the sum of `target`.

Notice that the solution set must not contain duplicate quadruplets.


Example 1:
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

Example 2:
Input: nums = [], target = 0
Output: []

Constraints:
`0 <= nums.length <= 200`
`-109 <= nums[i] <= 109`
`-109 <= target <= 109`",Medium
99,Majority Element II,"Given an integer array of size `n`, find all elements that appear more than `⌊ n/3 ⌋` times.

Follow-up: Could you solve the problem in linear time and in O(1) space?

Example 1:
Input: nums = [3,2,3]
Output: [3]

Example 2:
Input: nums = [1]
Output: [1]

Example 3:
Input: nums = [1,2]
Output: [1,2]

Constraints:
`1 <= nums.length <= 5 * 104`
`-109 <= nums[i] <= 109`",Medium
100,Combinations,"Given two integers `n` and `k`, return all possible combinations of `k` numbers out of the range `[1, n]`.

You may return the answer in any order.


Example 1:
Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

Example 2:
Input: n = 1, k = 1
Output: [[1]]

Constraints:
`1 <= n <= 20`
`1 <= k <= n`",Medium
101,Find the Duplicate Number,"Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.

There is only one repeated number in `nums`, return this repeated number.


Example 1:
Input: nums = [1,3,4,2,2]
Output: 2

Example 2:
Input: nums = [3,1,3,4,2]
Output: 3

Example 3:
Input: nums = [1,1]
Output: 1

Example 4:
Input: nums = [1,1,2]
Output: 1

Constraints:
`2 <= n <= 3 * 104`
`nums.length == n + 1`
`1 <= nums[i] <= n`
All the integers in `nums` appear only once except for precisely one integer which appears two or more times.

Follow up:
How can we prove that at least one duplicate number must exist in `nums`?
Can you solve the problem without modifying the array `nums`?
Can you solve the problem using only constant, `O(1)` extra space?
Can you solve the problem with runtime complexity less than `O(n2)`?",Medium
102,First Missing Positive,"Given an unsorted integer array `nums`, find the smallest missing positive integer.


Example 1:
Input: nums = [1,2,0]
Output: 3

Example 2:
Input: nums = [3,4,-1,1]
Output: 2

Example 3:
Input: nums = [7,8,9,11,12]
Output: 1

Constraints:
`0 <= nums.length <= 300`
`-231 <= nums[i] <= 231 - 1`
Follow up: Could you implement an algorithm that runs in `O(n)` time and uses constant extra space?",Hard
103,4Sum II,"Given four lists A, B, C, D of integer values, compute how many tuples `(i, j, k, l)` there are such that `A[i] + B[j] + C[k] + D[l]` is zero.

To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.


Example:
Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
Output:
2
Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0",Medium
104,Longest Consecutive Sequence,"Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.


Example 1:
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.


Example 2:
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9

Constraints:
`0 <= nums.length <= 104`
`-109 <= nums[i] <= 109`
Follow up: Could you implement the `O(n)` solution?",Hard
105,Sliding Window Maximum,"You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.


Example 1:
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

Example 2:
Input: nums = [1], k = 1
Output: [1]

Example 3:
Input: nums = [1,-1], k = 1
Output: [1,-1]

Example 4:
Input: nums = [9,11], k = 2
Output: [11]

Example 5:
Input: nums = [4,-2], k = 2
Output: [4]

Constraints:
`1 <= nums.length <= 105`
`-104 <= nums[i] <= 104`
`1 <= k <= nums.length`",Hard
106,Merge k Sorted Lists,"You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.


Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

Example 2:
Input: lists = []
Output: []

Example 3:
Input: lists = [[]]
Output: []

Constraints:
`k == lists.length`
`0 <= k <= 10^4`
`0 <= lists[i].length <= 500`
`-10^4 <= lists[i][j] <= 10^4`
`lists[i]` is sorted in ascending order.

The sum of `lists[i].length` won't exceed `10^4`.",Hard
107,Sort List,"Given the `head` of a linked list, return the list after sorting it in ascending order.

Follow up: Can you sort the linked list in `O(n logn)` time and `O(1)` memory (i.e. constant space)?

Example 1:
Input: head = [4,2,1,3]
Output: [1,2,3,4]

Example 2:
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]

Example 3:
Input: head = []
Output: []

Constraints:
The number of nodes in the list is in the range `[0, 5 * 104]`.

`-105 <= Node.val <= 105`",Medium
108,Word Ladder,"A transformation sequence from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:
Every adjacent pair of words differs by a single letter.

Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.

`sk == endWord`
Given two words, `beginWord` and `endWord`, and a dictionary `wordList`, return the number of words in the shortest transformation sequence from `beginWord` to `endWord`, or `0` if no such sequence exists.


Example 1:
Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]
Output: 5
Explanation: One shortest transformation sequence is ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> cog"", which is 5 words long.


Example 2:
Input: beginWord = ""hit"", endWord = ""cog"", wordList = [""hot"",""dot"",""dog"",""lot"",""log""]
Output: 0
Explanation: The endWord ""cog"" is not in wordList, therefore there is no valid transformation sequence.


Constraints:
`1 <= beginWord.length <= 10`
`endWord.length == beginWord.length`
`1 <= wordList.length <= 5000`
`wordList[i].length == beginWord.length`
`beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.

`beginWord != endWord`
All the words in `wordList` are unique.",Hard
109,Binary Tree Maximum Path Sum,"A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node's values in the path.

Given the `root` of a binary tree, return the maximum path sum of any path.


Example 1:
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.


Example 2:
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.


Constraints:
The number of nodes in the tree is in the range `[1, 3 * 104]`.

`-1000 <= Node.val <= 1000`",Hard
110,Median of Two Sorted Arrays,"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.


Example 1:
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.


Example 2:
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.


Example 3:
Input: nums1 = [0,0], nums2 = [0,0]
Output: 0.00000

Example 4:
Input: nums1 = [], nums2 = [1]
Output: 1.00000

Example 5:
Input: nums1 = [2], nums2 = []
Output: 2.00000

Constraints:
`nums1.length == m`
`nums2.length == n`
`0 <= m <= 1000`
`0 <= n <= 1000`
`1 <= m + n <= 2000`
`-106 <= nums1[i], nums2[i] <= 106`
Follow up: The overall run time complexity should be `O(log (m+n))`.",Hard
111,Kth Smallest Element in a Sorted Matrix,"Given an `n x n` `matrix` where each of the rows and columns are sorted in ascending order, return the `kth` smallest element in the matrix.

Note that it is the `kth` smallest element in the sorted order, not the `kth` distinct element.


Example 1:
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13

Example 2:
Input: matrix = [[-5]], k = 1
Output: -5

Constraints:
`n == matrix.length`
`n == matrix[i].length`
`1 <= n <= 300`
`-109 <= matrix[i][j] <= 109`
All the rows and columns of `matrix` are guaranteed to be sorted in non-degreasing order.

`1 <= k <= n2`",Medium
112,Max Points on a Line,"Given an array of `points` where `points[i] = [xi, yi]` represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.


Example 1:
Input: points = [[1,1],[2,2],[3,3]]
Output: 3

Example 2:
Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4

Constraints:
`1 <= points.length <= 300`
`points[i].length == 2`
`-104 <= xi, yi <= 104`
All the `points` are unique.",Hard
113,Game of Life,"According to Wikipedia's article: ""The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.""
The board is made up of an `m x n` grid of cells, where each cell has an initial state: live (represented by a `1`) or dead (represented by a `0`). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population.

Any live cell with two or three live neighbors lives on to the next generation.

Any live cell with more than three live neighbors dies, as if by over-population.

Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return the next state.


Example 1:
Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]

Example 2:
Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]

Constraints:
`m == board.length`
`n == board[i].length`
`1 <= m, n <= 25`
`board[i][j]` is `0` or `1`.

Follow up:
Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.

In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?",Medium
114,Binary Tree Maximum Path Sum,"A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node's values in the path.

Given the `root` of a binary tree, return the maximum path sum of any path.


Example 1:
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.


Example 2:
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.


Constraints:
The number of nodes in the tree is in the range `[1, 3 * 104]`.

`-1000 <= Node.val <= 1000`",Hard
